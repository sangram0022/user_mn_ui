# GitLab CI/CD Pipeline with Comprehensive Quality Gates
# Two-phase pipeline: PR/Push validation + Manual production deployment

variables:
  # Docker Configuration
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"

  # Application Configuration
  APP_NAME: "usermn1"
  REACT_VERSION: "19"
  NODE_VERSION: "20"

  # AWS Configuration
  AWS_DEFAULT_REGION: "us-east-1"
  ECR_REGISTRY: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"

  # Terraform Configuration
  TF_VERSION: "1.6.0"
  TF_ROOT: "terraform"

  # Quality Gates Configuration
  COVERAGE_THRESHOLD: "80"
  SECURITY_SCAN_FAIL_THRESHOLD: "HIGH"
  PERFORMANCE_BUDGET_FILE: "lighthouse-budget.json"

# GitLab CI/CD Stages
stages:
  - validate
  - build
  - test
  - security
  - quality
  - package
  - deploy-infrastructure
  - deploy-application
  - post-deploy
  - cleanup

# Include templates for reusability
include:
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Container-Scanning.gitlab-ci.yml

# Global before_script
.before_script_template: &before_script
  - echo "Starting CI/CD pipeline for $CI_COMMIT_REF_NAME"
  - export IMAGE_TAG="${CI_COMMIT_SHA:0:8}"
  - export ENVIRONMENT=$([ "$CI_COMMIT_REF_NAME" = "main" ] && echo "prod" || echo "dev")

# ============================================================================
# PHASE 1: PR/PUSH QUALITY GATES (Automatic)
# ============================================================================

# Validation Stage
validate-code:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script: *before_script
  script:
    - make lint-check
    - make type-check
    - make format-check
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"
  cache:
    key: "$CI_COMMIT_REF_SLUG-node-modules"
    paths:
      - node_modules/
  artifacts:
    reports:
      junit: reports/lint-report.xml
    paths:
      - reports/
    expire_in: 1 hour

validate-terraform:
  stage: validate
  image: hashicorp/terraform:${TF_VERSION}
  before_script: *before_script
  script:
    - make terraform-validate
    - make terraform-plan
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"
  artifacts:
    reports:
      junit: reports/terraform-validate.xml
    paths:
      - terraform/plan.out
      - reports/
    expire_in: 1 hour

# Build Stage
build-application:
  stage: build
  image: node:${NODE_VERSION}-alpine
  services:
    - docker:dind
  before_script: *before_script
  script:
    - make install-dependencies
    - make build-production
    - make build-docker-image
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  cache:
    key: "$CI_COMMIT_REF_SLUG-node-modules"
    paths:
      - node_modules/
    policy: pull-push
  artifacts:
    paths:
      - dist/
      - docker-image.tar
    expire_in: 2 hours

# Test Stage
unit-tests:
  stage: test
  image: node:${NODE_VERSION}-alpine
  before_script: *before_script
  script:
    - make test-unit
    - make test-coverage
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  cache:
    key: "$CI_COMMIT_REF_SLUG-node-modules"
    paths:
      - node_modules/
    policy: pull
  artifacts:
    reports:
      junit: reports/jest-junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
      - reports/
    expire_in: 1 week
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)%/'

integration-tests:
  stage: test
  image: node:${NODE_VERSION}-alpine
  services:
    - docker:dind
  before_script: *before_script
  script:
    - make test-integration
    - make test-e2e
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  dependencies:
    - build-application
  artifacts:
    reports:
      junit: reports/integration-junit.xml
    paths:
      - reports/
      - screenshots/
    expire_in: 1 week
    when: always

performance-tests:
  stage: test
  image: node:${NODE_VERSION}-alpine
  before_script: *before_script
  script:
    - make test-performance
    - make lighthouse-audit
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  dependencies:
    - build-application
  artifacts:
    reports:
      performance: reports/lighthouse-report.json
    paths:
      - reports/
    expire_in: 1 week

# Security Stage
security-scan-code:
  stage: security
  extends: .sast
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

security-scan-secrets:
  stage: security
  extends: .secret-detection
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

security-scan-dependencies:
  stage: security
  extends: .dependency_scanning
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

security-scan-container:
  stage: security
  extends: .container_scanning
  dependencies:
    - build-application
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

security-scan-custom:
  stage: security
  image: alpine:latest
  before_script: *before_script
  script:
    - make security-audit
    - make vulnerability-scan
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  artifacts:
    reports:
      junit: reports/security-audit.xml
    paths:
      - reports/
    expire_in: 1 week

# Quality Stage
code-quality:
  stage: quality
  image: sonarqube/sonar-scanner-cli:latest
  before_script: *before_script
  script:
    - make sonar-analysis
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  dependencies:
    - unit-tests
  artifacts:
    reports:
      junit: reports/sonar-report.xml
    expire_in: 1 week

accessibility-tests:
  stage: quality
  image: node:${NODE_VERSION}-alpine
  before_script: *before_script
  script:
    - make test-accessibility
    - make wcag-compliance-check
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  dependencies:
    - build-application
  artifacts:
    reports:
      accessibility: reports/pa11y-report.json
    paths:
      - reports/
    expire_in: 1 week

# Package Stage
package-application:
  stage: package
  image: docker:latest
  services:
    - docker:dind
  before_script: *before_script
  script:
    - make docker-login
    - make docker-build-production
    - make docker-scan-security
    - make docker-push
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
  dependencies:
    - build-application
  artifacts:
    paths:
      - docker-scan-results.json
    expire_in: 1 week

# ============================================================================
# PHASE 2: PRODUCTION DEPLOYMENT (Manual Approval Required)
# ============================================================================

# Infrastructure Deployment
deploy-infrastructure-staging:
  stage: deploy-infrastructure
  image: hashicorp/terraform:${TF_VERSION}
  before_script: *before_script
  script:
    - make terraform-init
    - make terraform-plan-staging
    - make terraform-apply-staging
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: staging
    url: https://staging.${APP_NAME}.com
  artifacts:
    paths:
      - terraform/staging.tfstate
    expire_in: 1 week

deploy-infrastructure-production:
  stage: deploy-infrastructure
  image: hashicorp/terraform:${TF_VERSION}
  before_script: *before_script
  script:
    - make terraform-init
    - make terraform-plan-production
    - make terraform-apply-production
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: production
    url: https://${APP_NAME}.com
  dependencies:
    - deploy-infrastructure-staging
  artifacts:
    paths:
      - terraform/production.tfstate
    expire_in: 1 month

# Application Deployment
deploy-application-staging:
  stage: deploy-application
  image: amazon/aws-cli:latest
  before_script: *before_script
  script:
    - make deploy-ecs-staging
    - make run-smoke-tests-staging
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: staging
    url: https://staging.${APP_NAME}.com
  dependencies:
    - deploy-infrastructure-staging
    - package-application

deploy-application-production:
  stage: deploy-application
  image: amazon/aws-cli:latest
  before_script: *before_script
  script:
    - make deploy-ecs-production
    - make run-smoke-tests-production
    - make setup-monitoring-alerts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: production
    url: https://${APP_NAME}.com
    on_stop: stop-production
  dependencies:
    - deploy-infrastructure-production
    - package-application

# Blue/Green Deployment (Advanced)
deploy-blue-green:
  stage: deploy-application
  image: amazon/aws-cli:latest
  before_script: *before_script
  script:
    - make deploy-blue-green-setup
    - make deploy-green-environment
    - make run-smoke-tests-green
    - make switch-traffic-to-green
    - make cleanup-blue-environment
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: production-blue-green
    url: https://${APP_NAME}.com
  dependencies:
    - deploy-infrastructure-production
    - package-application

# Post-Deployment Stage
post-deploy-tests:
  stage: post-deploy
  image: node:${NODE_VERSION}-alpine
  before_script: *before_script
  script:
    - make test-post-deployment
    - make validate-deployment-health
    - make load-test-production
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  dependencies:
    - deploy-application-production
  artifacts:
    reports:
      junit: reports/post-deploy-tests.xml
    paths:
      - reports/
    expire_in: 1 month

deployment-notification:
  stage: post-deploy
  image: alpine:latest
  before_script: *before_script
  script:
    - make send-deployment-notification
    - make update-deployment-status
    - make generate-deployment-report
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  dependencies:
    - deploy-application-production
  artifacts:
    paths:
      - deployment-report.html
    expire_in: 3 months

# Cleanup Stage
cleanup-staging:
  stage: cleanup
  image: hashicorp/terraform:${TF_VERSION}
  before_script: *before_script
  script:
    - make cleanup-staging-environment
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: delayed
      start_in: 2 hours
  dependencies:
    - post-deploy-tests

stop-production:
  stage: cleanup
  image: amazon/aws-cli:latest
  before_script: *before_script
  script:
    - make stop-production-environment
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: production
    action: stop

# ============================================================================
# QUALITY GATE CHECKS
# ============================================================================

# Quality Gate: Coverage Check
.coverage_check: &coverage_check
  - |
    COVERAGE=$(grep -Po '(?<=<coverage line-rate=")[^"]*' coverage/cobertura-coverage.xml | head -1)
    COVERAGE_PERCENT=$(echo "$COVERAGE * 100" | bc)
    if (( $(echo "$COVERAGE_PERCENT < $COVERAGE_THRESHOLD" | bc -l) )); then
      echo "Coverage $COVERAGE_PERCENT% is below threshold $COVERAGE_THRESHOLD%"
      exit 1
    fi

# Quality Gate: Security Check
.security_check: &security_check
  - |
    if [ -f "gl-sast-report.json" ]; then
      HIGH_VULNS=$(jq '[.vulnerabilities[] | select(.severity == "High")] | length' gl-sast-report.json)
      if [ "$HIGH_VULNS" -gt 0 ]; then
        echo "Found $HIGH_VULNS high severity vulnerabilities"
        exit 1
      fi
    fi

# Quality Gate: Performance Check
.performance_check: &performance_check
  - |
    if [ -f "reports/lighthouse-report.json" ]; then
      PERFORMANCE_SCORE=$(jq '.lhr.categories.performance.score * 100' reports/lighthouse-report.json)
      if (( $(echo "$PERFORMANCE_SCORE < 90" | bc -l) )); then
        echo "Performance score $PERFORMANCE_SCORE is below threshold 90"
        exit 1
      fi
    fi
