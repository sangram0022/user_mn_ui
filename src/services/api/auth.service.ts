/**
 * Authentication & Profile API Service
 * Reference: API_COMPLETE_REFERENCE.md - Authentication & Profile APIs (Endpoints 1-16)
 *
 * Features:
 * - User authentication (login, logout, refresh)
 * - Secure authentication with httpOnly cookies
 * - User registration with email verification
 * - Password management (change, reset, forgot)
 * - Email verification and resend
 * - CSRF token management
 * - User profile management (get, update)
 *
 * Rate Limits:
 * - POST /api/auth/login: 10 requests/minute
 * - POST /api/auth/register: 5 requests/minute
 * - POST /api/auth/logout: 30 requests/minute
 * - POST /api/auth/refresh: 20 requests/minute
 * - POST /api/auth/forgot-password: 3 requests/hour
 * - POST /api/auth/reset-password: 5 requests/hour
 * - POST /api/auth/change-password: 10 requests/hour
 * - GET /api/auth/csrf-token: 30 requests/minute
 *
 * Password Requirements:
 * - Minimum 8 characters
 * - At least one uppercase letter (A-Z)
 * - At least one lowercase letter (a-z)
 * - At least one number (0-9)
 * - At least one special character (!@#$%^&*)
 *
 * @author Generated by GitHub Copilot
 */

import { apiClient } from '@lib/api/client';
import type { ChangePasswordRequest, RegisterRequest, ResetPasswordRequest } from '@shared/types';
import { logger } from '@shared/utils/logger';

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface AuthToken {
  accessToken: string;
  refreshToken?: string;
  expiresIn: number;
  tokenType: string;
}

export interface AuthUser {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  roles: string[];
  isEmailVerified: boolean;
  isActive: boolean;
  createdAt: string;
}

export interface LoginResponse {
  token: AuthToken;
  user: AuthUser;
  message: string;
}

/**
 * Authentication Service
 * Handles all authentication-related API calls
 */
export class AuthService {
  /**
   * User Login
   * POST /auth/login
   *
   * Authenticate user and receive access token and refresh token.
   *
   * @param credentials - User email and password
   * @returns LoginResponse with token and user data
   *
   * @example
   * const response = await authService.login({
   *   email: 'user@example.com',
   *   password: 'SecurePassword123!'
   * });
   */
  async login(credentials: LoginCredentials): Promise<LoginResponse> {
    try {
      logger.debug('[AuthService] Login attempt', { email: credentials.email });

      const response = await apiClient.login(credentials.email, credentials.password);

      // Check if this is a secure login response (httpOnly cookies)
      if ('message' in response) {
        const secureResponse =
          response as import('@shared/types/api-backend.types').SecureLoginResponse;
        logger.info('[AuthService] Secure login successful', {
          userId: secureResponse.user.user_id,
          email: credentials.email,
        });

        return {
          token: {
            accessToken: '', // Not in response body for secure login
            refreshToken: '', // Not in response body for secure login
            expiresIn: 900, // 15 minutes
            tokenType: 'bearer',
          },
          user: {
            id: secureResponse.user.user_id,
            email: secureResponse.user.email,
            firstName: secureResponse.user.first_name || '',
            lastName: secureResponse.user.last_name || '',
            roles: secureResponse.user.roles,
            isEmailVerified: secureResponse.user.is_verified ?? true,
            isActive: secureResponse.user.is_active ?? true,
            createdAt: secureResponse.user.last_login_at || new Date().toISOString(),
          },
          message: secureResponse.message,
        };
      }

      // Regular login response with tokens
      const regularResponse = response as import('@shared/types/api-backend.types').LoginResponse;
      logger.info('[AuthService] Login successful', {
        userId: regularResponse.user.user_id,
        email: credentials.email,
      });

      return {
        token: {
          accessToken: regularResponse.access_token,
          refreshToken: regularResponse.refresh_token,
          expiresIn: regularResponse.expires_in,
          tokenType: regularResponse.token_type,
        },
        user: {
          id: regularResponse.user.user_id,
          email: regularResponse.user.email,
          firstName: regularResponse.user.first_name,
          lastName: regularResponse.user.last_name,
          roles: regularResponse.user.roles,
          isEmailVerified: regularResponse.user.is_verified,
          isActive: regularResponse.user.is_active,
          createdAt: new Date().toISOString(),
        },
        message: 'Login successful',
      };
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Login failed', error);
      } else {
        logger.error('[AuthService] Login failed');
      }
      throw error;
    }
  }

  /**
   * Secure Login (httpOnly Cookies)
   * POST /auth/login-secure
   *
   * Login with httpOnly cookie-based token storage.
   * Recommended for maximum security against XSS attacks.
   *
   * @param credentials - User email and password
   * @returns LoginResponse with user data
   */
  async loginSecure(credentials: LoginCredentials): Promise<LoginResponse> {
    try {
      logger.debug('[AuthService] Secure login attempt', { email: credentials.email });

      const response = await apiClient.loginSecure(credentials.email, credentials.password);

      logger.info('[AuthService] Secure login successful', {
        userId: response.user.user_id,
        email: credentials.email,
      });

      return {
        token: {
          accessToken: '', // Not in response body for secure login
          refreshToken: '', // Not in response body for secure login
          expiresIn: 900, // 15 minutes
          tokenType: 'bearer',
        },
        user: {
          id: response.user.user_id,
          email: response.user.email,
          firstName: response.user.first_name || '',
          lastName: response.user.last_name || '',
          roles: response.user.roles,
          isEmailVerified: response.user.is_verified ?? true,
          isActive: response.user.is_active ?? true,
          createdAt: response.user.last_login_at || new Date().toISOString(),
        },
        message: response.message,
      };
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Secure login failed', error);
      } else {
        logger.error('[AuthService] Secure login failed');
      }
      throw error;
    }
  }

  /**
   * User Registration
   * POST /auth/register
   *
   * Register a new user account.
   *
   * Password Requirements:
   * - Minimum 8 characters
   * - At least one uppercase letter
   * - At least one lowercase letter
   * - At least one number
   * - At least one special character (!@#$%^&*)
   *
   * @param payload - Registration data
   * @returns Registered user data
   *
   * @example
   * const user = await authService.register({
   *   email: 'newuser@example.com',
   *   password: 'SecurePassword123!',
   *   first_name: 'Jane',
   *   last_name: 'Smith',
   * });
   */
  async register(payload: RegisterRequest) {
    try {
      logger.debug('[AuthService] Registration attempt', { email: payload.email });

      const response = await apiClient.register(payload);

      logger.info('[AuthService] Registration successful', {
        userId: response.user_id,
        email: payload.email,
      });

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Registration failed', error);
      } else {
        logger.error('[AuthService] Registration failed');
      }
      throw error;
    }
  }

  /**
   * Verify Email
   * POST /auth/verify-email
   *
   * Verify user email using verification token received in email.
   *
   * @param token - Verification token from email
   * @returns Verification result
   *
   * @example
   * const result = await authService.verifyEmail('verification-token-received-in-email');
   */
  async verifyEmail(token: string) {
    try {
      logger.debug('[AuthService] Email verification attempt');

      const response = await apiClient.verifyEmail(token);

      logger.info('[AuthService] Email verified successfully');

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Email verification failed', error);
      } else {
        logger.error('[AuthService] Email verification failed');
      }
      throw error;
    }
  }

  /**
   * Resend Verification Email
   * POST /auth/resend-verification
   *
   * Request a new verification email.
   *
   * @param email - User email address
   * @returns Resend result
   */
  async resendVerificationEmail(email: string) {
    try {
      logger.debug('[AuthService] Resending verification email', { email });

      const response = await apiClient.resendVerification({ email });

      logger.info('[AuthService] Verification email resent', { email });

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Resend verification failed', error);
      } else {
        logger.error('[AuthService] Resend verification failed');
      }
      throw error;
    }
  }

  /**
   * Forgot Password
   * POST /auth/forgot-password
   *
   * Request password reset email.
   *
   * @param email - User email address
   * @returns Password reset email sent confirmation
   *
   * @example
   * const result = await authService.forgotPassword('user@example.com');
   */
  async forgotPassword(email: string) {
    try {
      logger.debug('[AuthService] Forgot password request', { email });

      const response = await apiClient.forgotPassword(email);

      logger.info('[AuthService] Forgot password email sent', { email });

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Forgot password failed', error);
      } else {
        logger.error('[AuthService] Forgot password failed');
      }
      throw error;
    }
  }

  /**
   * Reset Password
   * POST /auth/reset-password
   *
   * Reset password using token from email.
   *
   * @param payload - Reset token and new password
   * @returns Password reset confirmation
   *
   * @example
   * const result = await authService.resetPassword({
   *   token: 'password-reset-token',
   *   new_password: 'NewSecurePassword123!'
   * });
   */
  async resetPassword(payload: ResetPasswordRequest) {
    try {
      logger.debug('[AuthService] Password reset attempt');

      const response = await apiClient.resetPassword(payload);

      logger.info('[AuthService] Password reset successful');

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Password reset failed', error);
      } else {
        logger.error('[AuthService] Password reset failed');
      }
      throw error;
    }
  }

  /**
   * Change Password
   * POST /auth/change-password
   *
   * Change password for authenticated user.
   *
   * @param payload - Current and new password
   * @returns Password change confirmation
   *
   * @example
   * const result = await authService.changePassword({
   *   current_password: 'CurrentPassword123!',
   *   new_password: 'NewSecurePassword456!'
   * });
   */
  async changePassword(payload: ChangePasswordRequest) {
    try {
      logger.debug('[AuthService] Password change attempt');

      const response = await apiClient.changePassword(payload);

      logger.info('[AuthService] Password changed successfully');

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Password change failed', error);
      } else {
        logger.error('[AuthService] Password change failed');
      }
      throw error;
    }
  }

  /**
   * Logout
   * POST /auth/logout
   *
   * Logout user and invalidate session.
   *
   * @returns Logout confirmation
   *
   * @example
   * const result = await authService.logout();
   */
  async logout() {
    try {
      logger.debug('[AuthService] Logout attempt');

      const response = await apiClient.logout();

      logger.info('[AuthService] Logout successful');

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Logout failed', error);
      } else {
        logger.error('[AuthService] Logout failed');
      }
      throw error;
    }
  }

  /**
   * Refresh Token
   * POST /auth/refresh
   *
   * Get a new access token using refresh token.
   *
   * @param refreshToken - Refresh token
   * @returns New access token
   */
  async refreshToken(refreshToken: string) {
    try {
      logger.debug('[AuthService] Token refresh attempt');

      const response = await apiClient.execute('/auth/refresh', {
        method: 'POST',
        body: JSON.stringify({ refresh_token: refreshToken }),
      });

      logger.info('[AuthService] Token refreshed successfully');

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Token refresh failed', error);
      } else {
        logger.error('[AuthService] Token refresh failed');
      }
      throw error;
    }
  }

  /**
   * Check if user is authenticated
   *
   * @returns True if user has valid auth token
   */
  isAuthenticated(): boolean {
    return apiClient.isAuthenticated();
  }

  /**
   * Get CSRF Token
   * GET /auth/csrf-token
   *
   * Retrieve CSRF token for POST/PUT/DELETE requests.
   *
   * @returns CSRF token
   */
  async getCSRFToken() {
    try {
      logger.debug('[AuthService] Getting CSRF token');

      const response = await apiClient.getCSRFToken();

      logger.debug('[AuthService] CSRF token retrieved');

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Failed to get CSRF token', error);
      } else {
        logger.error('[AuthService] Failed to get CSRF token');
      }
      throw error;
    }
  }

  /**
   * Refresh Token (Secure - httpOnly Cookies)
   * POST /auth/refresh-secure
   *
   * Refresh access token using httpOnly cookies.
   * Token is automatically stored in secure httpOnly cookie.
   *
   * @returns LoginResponse with updated token
   */
  async refreshSecure(): Promise<LoginResponse> {
    try {
      logger.debug('[AuthService] Refreshing token (secure)');

      const response = await apiClient.refreshSecure();

      logger.info('[AuthService] Token refreshed successfully (secure)');

      return {
        token: {
          accessToken: response.access_token,
          refreshToken: response.refresh_token,
          expiresIn: response.expires_in,
          tokenType: response.token_type,
        },
        user: {
          id: response.user.user_id ?? '',
          email: response.user.email ?? '',
          firstName: response.user.first_name || '',
          lastName: response.user.last_name || '',
          roles: response.user.roles || [],
          isEmailVerified: false,
          isActive: true,
          createdAt: '',
        },
        message: 'Token refreshed',
      };
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Secure token refresh failed', error);
      } else {
        logger.error('[AuthService] Secure token refresh failed');
      }
      throw error;
    }
  }

  /**
   * Logout (Secure - httpOnly Cookies)
   * POST /auth/logout-secure
   *
   * Logout and clear httpOnly cookies.
   *
   * @returns Logout response
   */
  async logoutSecure() {
    try {
      logger.debug('[AuthService] Logging out (secure)');

      const response = await apiClient.logoutSecure();

      logger.info('[AuthService] Logged out successfully (secure)');

      // Clear any local session data
      sessionStorage.removeItem('user');

      return response;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Secure logout failed', error);
      } else {
        logger.error('[AuthService] Secure logout failed');
      }
      throw error;
    }
  }

  /**
   * Validate CSRF Token
   * POST /auth/validate-csrf
   *
   * Manually validate CSRF token.
   * Typically handled automatically by CSRF interceptor.
   *
   * @param token - CSRF token to validate
   * @returns True if token is valid
   */
  async validateCsrf(token: string): Promise<boolean> {
    try {
      logger.debug('[AuthService] Validating CSRF token');

      await apiClient.validateCsrf(token);

      logger.debug('[AuthService] CSRF token is valid');

      return true;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] CSRF validation failed', error);
      } else {
        logger.error('[AuthService] CSRF validation failed');
      }
      return false;
    }
  }

  // ============================================================================
  // PROFILE MANAGEMENT (Endpoints 12-16)
  // ============================================================================

  /**
   * Get User Profile
   * GET /api/profile
   *
   * Retrieve current authenticated user's profile information.
   *
   * Rate Limit: 30 requests per minute
   *
   * @returns User profile with full details
   *
   * @example
   * const profile = await authService.getProfile();
   * console.log(`Welcome ${profile.first_name} ${profile.last_name}`);
   */
  async getProfile(): Promise<{
    user_id: string;
    email: string;
    first_name: string;
    last_name: string;
    roles: string[];
    is_active: boolean;
    is_verified: boolean;
    is_approved: boolean;
    approved_by: string | null;
    approved_at: string | null;
    created_at: string;
    updated_at: string | null;
    last_login_at: string | null;
    login_count: number;
    preferences?: Record<string, unknown>;
    metadata?: Record<string, unknown>;
  }> {
    try {
      logger.debug('[AuthService] Fetching user profile');

      const profile = await apiClient.execute<{
        user_id: string;
        email: string;
        first_name: string;
        last_name: string;
        roles: string[];
        is_active: boolean;
        is_verified: boolean;
        is_approved: boolean;
        approved_by: string | null;
        approved_at: string | null;
        created_at: string;
        updated_at: string | null;
        last_login_at: string | null;
        login_count: number;
        preferences?: Record<string, unknown>;
        metadata?: Record<string, unknown>;
      }>('/api/profile', { method: 'GET' });

      logger.info('[AuthService] Profile retrieved', {
        userId: profile.user_id,
        email: profile.email,
      });

      return profile;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Failed to fetch profile', error);
      } else {
        logger.error('[AuthService] Failed to fetch profile');
      }
      throw error;
    }
  }

  /**
   * Update User Profile
   * PUT /api/profile
   *
   * Update current user's profile information.
   *
   * Rate Limit: 10 requests per minute
   *
   * @param updates - Profile fields to update
   * @returns Updated profile
   *
   * @example
   * const updated = await authService.updateProfile({
   *   first_name: 'Jane',
   *   last_name: 'Doe',
   *   preferences: { theme: 'dark', language: 'en' }
   * });
   */
  async updateProfile(updates: {
    first_name?: string;
    last_name?: string;
    preferences?: Record<string, unknown>;
    metadata?: Record<string, unknown>;
  }): Promise<{
    user_id: string;
    email: string;
    first_name: string;
    last_name: string;
    roles: string[];
    is_active: boolean;
    is_verified: boolean;
    is_approved: boolean;
    approved_by: string | null;
    approved_at: string | null;
    created_at: string;
    updated_at: string | null;
    last_login_at: string | null;
    login_count: number;
    preferences?: Record<string, unknown>;
    metadata?: Record<string, unknown>;
  }> {
    try {
      logger.debug('[AuthService] Updating profile');

      const profile = await apiClient.execute<{
        user_id: string;
        email: string;
        first_name: string;
        last_name: string;
        roles: string[];
        is_active: boolean;
        is_verified: boolean;
        is_approved: boolean;
        approved_by: string | null;
        approved_at: string | null;
        created_at: string;
        updated_at: string | null;
        last_login_at: string | null;
        login_count: number;
        preferences?: Record<string, unknown>;
        metadata?: Record<string, unknown>;
      }>('/api/profile', {
        method: 'PUT',
        body: JSON.stringify(updates),
      });

      logger.info('[AuthService] Profile updated', {
        userId: profile.user_id,
      });

      return profile;
    } catch (error) {
      if (error instanceof Error) {
        logger.error('[AuthService] Failed to update profile', error);
      } else {
        logger.error('[AuthService] Failed to update profile');
      }
      throw error;
    }
  }
}

export const authService = new AuthService();

export default authService;
