# AWS AppSync GraphQL Schema for User Management
# Optimized for offline-first operations with automatic conflict resolution

type User
  @model
  @auth(
    rules: [
      { allow: private, operations: [read] }
      { allow: owner, operations: [create, read, update, delete] }
      {
        allow: groups
        groups: ["Admin"]
        operations: [create, read, update, delete]
      }
    ]
  ) {
  id: ID!
  username: String! @index(name: "byUsername", queryField: "userByUsername")
  email: String! @index(name: "byEmail", queryField: "userByEmail")
  firstName: String!
  lastName: String!
  isActive: Boolean!
  role: UserRole!
  permissions: [String!]!
  profile: UserProfile
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  lastLoginAt: AWSDateTime
  loginCount: Int!
  owner: String @auth(rules: [{ allow: owner, operations: [read] }])
}

type UserProfile
  @model
  @auth(
    rules: [
      { allow: owner, operations: [create, read, update, delete] }
      { allow: groups, groups: ["Admin"], operations: [read, update] }
    ]
  ) {
  id: ID!
  userId: ID! @index(name: "byUserId", queryField: "profileByUserId")
  avatar: String
  bio: String
  phoneNumber: String
  timezone: String
  language: String
  theme: Theme!
  notifications: NotificationSettings!
  twoFactorEnabled: Boolean!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  owner: String @auth(rules: [{ allow: owner, operations: [read] }])
}

type AuditLog
  @model
  @auth(
    rules: [
      { allow: groups, groups: ["Admin"], operations: [create, read] }
      { allow: private, operations: [create] }
    ]
  ) {
  id: ID!
  userId: ID! @index(name: "byUserId", queryField: "auditLogsByUser")
  action: AuditAction!
  resourceType: String!
  resourceId: String!
  details: AWSJSON
  ipAddress: String!
  userAgent: String!
  success: Boolean!
  errorMessage: String
  timestamp: AWSDateTime!
    @index(name: "byTimestamp", queryField: "auditLogsByTimestamp")
}

type Session
  @model
  @auth(
    rules: [
      { allow: owner, operations: [create, read, update, delete] }
      { allow: groups, groups: ["Admin"], operations: [read, delete] }
    ]
  ) {
  id: ID!
  userId: ID! @index(name: "byUserId", queryField: "sessionsByUser")
  token: String!
  refreshToken: String
  deviceInfo: String
  ipAddress: String!
  expiresAt: AWSDateTime!
  isActive: Boolean!
  createdAt: AWSDateTime!
  lastActivity: AWSDateTime!
  owner: String @auth(rules: [{ allow: owner, operations: [read] }])
}

enum UserRole {
  ADMIN
  USER
  MODERATOR
  VIEWER
}

enum Theme {
  LIGHT
  DARK
  SYSTEM
}

enum AuditAction {
  LOGIN
  LOGOUT
  REGISTER
  UPDATE_PROFILE
  CHANGE_PASSWORD
  ENABLE_2FA
  DISABLE_2FA
  DELETE_ACCOUNT
  ADMIN_ACTION
  PERMISSION_CHANGE
}

type NotificationSettings {
  email: Boolean!
  push: Boolean!
  sms: Boolean!
  marketing: Boolean!
}

# Real-time subscriptions for live updates
type Subscription {
  onUserUpdate(id: ID!): User
    @aws_subscribe(mutations: ["updateUser"])
    @auth(rules: [{ allow: owner }, { allow: groups, groups: ["Admin"] }])

  onUserCreated: User
    @aws_subscribe(mutations: ["createUser"])
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  onAuditLogCreated(userId: ID): AuditLog
    @aws_subscribe(mutations: ["createAuditLog"])
    @auth(rules: [{ allow: owner }, { allow: groups, groups: ["Admin"] }])
}

# Custom mutations for complex operations
type Mutation {
  # User management operations
  activateUser(id: ID!): User
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  deactivateUser(id: ID!): User
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  changeUserRole(id: ID!, role: UserRole!): User
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  updateUserPermissions(id: ID!, permissions: [String!]!): User
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  # Authentication operations
  refreshSession(refreshToken: String!): Session

  invalidateAllSessions(userId: ID!): [Session]
    @auth(rules: [{ allow: owner }, { allow: groups, groups: ["Admin"] }])

  # Bulk operations for admin efficiency
  bulkUpdateUsers(userIds: [ID!]!, updates: UserUpdateInput!): [User]
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  bulkDeactivateUsers(userIds: [ID!]!): [User]
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])
}

# Custom queries for complex filtering
type Query {
  # Advanced user queries
  searchUsers(
    query: String!
    role: UserRole
    isActive: Boolean
    limit: Int
    nextToken: String
  ): UserSearchResult @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  getUserStats: UserStats @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  getActiveUsers(limit: Int, nextToken: String): UserConnection
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  # Audit and analytics
  getAuditLogsByDateRange(
    startDate: AWSDateTime!
    endDate: AWSDateTime!
    action: AuditAction
    userId: ID
    limit: Int
    nextToken: String
  ): AuditLogConnection @auth(rules: [{ allow: groups, groups: ["Admin"] }])
}

# Custom types for complex operations
input UserUpdateInput {
  firstName: String
  lastName: String
  email: String
  role: UserRole
  isActive: Boolean
  permissions: [String!]
}

type UserSearchResult {
  users: [User!]!
  total: Int!
  nextToken: String
}

type UserStats {
  totalUsers: Int!
  activeUsers: Int!
  newUsersToday: Int!
  newUsersThisWeek: Int!
  newUsersThisMonth: Int!
  usersByRole: [RoleCount!]!
  recentActivity: [User!]!
}

type RoleCount {
  role: UserRole!
  count: Int!
}

type UserConnection {
  items: [User!]!
  nextToken: String
}

type AuditLogConnection {
  items: [AuditLog!]!
  nextToken: String
}
